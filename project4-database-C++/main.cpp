
//CSE220 Project 6
// Name: 
// Programming environment used: VS or g++


// READ BEFORE YOU START:
// You are given a partially completed program that creates a list of students.
// Each student has the corresponding information: name, roll number and student type.
// This information is stored as an object of Student class.
// The classes Undergrad and Grad are child classes of the Stduent class.
// When adding a new student, these child classes are used to make the student node of the list.

//
// To begin, you should trace through the given code and understand how it works.
// Please read the instructions above each required function and follow the directions carefully.
// Do not modify given code.
//
// You can assume that all input is valid:
// Valid name:	String containing alphabetical letters
// Valid roll number: a positive integer

#include <iostream>
#include <fstream>
#include <string>
#include "Container.h"
#include "student.h"
#include "grad.h"
#include "undergrad.h"

using namespace std;

// forward declarations of functions already implemented:
void executeAction(char c);
Student* searchStudent(string name_input);


// forward declarations of functions that need implementation:
void addStudent(string name_input, int rollNo_input, studentType type);			// 10 points
void displayList();							// 10 points
void removeStudent(string name_input);		// 10 points
void deleteList();							// 10 points
void sort(Container **head);				// 10 points
void save(string fileName);					// 10 points
void load(string fileName);					// 10 points

Container* list = NULL;				// global list

int main()
{
	char c = 'i';				// initialized to a dummy value

	load("list.txt");			// During first execution, there will be no list.txt in source directory. list.txt is generated by save() while exiting the program.

	do {
		cout << "\nCSE220 Project 5\n";
		cout << "Choose an action:\n";
		cout << "\t a: add a new student\n";
		cout << "\t d: display list of students\n";
		cout << "\t c: change roll number of a student\n";
		cout << "\t r: remove a student\n";
		cout << "\t s: sort the list\n";
		cout << "\t q: quit\n";
		cin >> c;
		cin.ignore();
		executeAction(c);
	} while (c != 'q');

	save("list.txt");			// save the linked list to a file

	deleteList();				// delete the list before exiting the program

	return 0;
}

// Ask for details from user for the given selection and perform that action
// Read the function case by case
void executeAction(char c)
{
	string name_input;
	int rollNo_input;
	int type_input = 2;
	studentType type;
	Student* studentFound = NULL;

	switch (c)
	{
	case 'a':	// add student
				// input student details from user
		cout << endl << "Enter student's name: ";
		getline(cin, name_input);
		cout << "Enter roll number: ";
		cin >> rollNo_input;
		cin.ignore();

		while (!(type_input == 0 || type_input == 1))
		{
			cout << endl << "Enter student type: " << endl;
			cout << "0. Undergrad " << endl;
			cout << "1. Grad" << endl;
			cin >> type_input;
			cin.ignore();
		}
		
		type = (studentType)type_input;

		// searchStudent() will return the student node if found, else returns NULL
		studentFound = searchStudent(name_input);
		if (studentFound == NULL)
		{
			addStudent(name_input, rollNo_input, type);
			cout << endl << "Student added to list!" << endl << endl;
		}
		else
			cout << endl << "Student already present in the list!" << endl << endl;

		break;

	case 'd':		// display the list
		displayList();
		break;

	case 'r':		// remove a student
		cout << endl << "Enter student's name: ";
		getline(cin, name_input);
		studentFound = searchStudent(name_input);
		if (studentFound != NULL)
		{
			removeStudent(name_input);
			cout << endl << "Student removed!" << endl << endl;
		}
		else
			cout << endl << "Student not present in the list!" << endl << endl;

		
		break;

	case 's':		// sort the list
		sort(&list);
		cout << endl << "List sorted!" << endl << endl;
		break;

	case 'c':		// change roll number
		cout << endl << "Enter student's name: ";
		getline(cin, name_input);
		// searchStudent() will return the student node if found, else returns NULL
		studentFound = searchStudent(name_input);
		if (studentFound == NULL)
		{
			cout << endl << "Student not in list!" << endl << endl;
		}
		else
		{
			// if stduent exists in the list, then ask user for new roll number
			cout << endl << "Enter new roll number: ";
			cin >> rollNo_input;
			cin.ignore();
			

			// Q3c Call changeRollNo() here   (2 points)
			// 'studentFound' contains the student whose roll number is to be changed.
			// 'rollNo_input' contains the new roll number of the student.
			// Call the function with appropriate function arguments.
			changeRollNo(studentFound, rollNo_input);

			cout << endl << "Roll number changed!" << endl << endl;
		}
		break;

	case 'q':		// quit
		break;

	default: cout << c << " is invalid input!\n";
	}

}

// No implementation needed here, however it may be helpful to review this function
Student* searchStudent(string name_input)
{

	Container* tempList = list;			// work on a copy of 'list'

	while (tempList != NULL)			// parse till end of list
	{
		if (tempList->student->getName() == name_input)
		{
			return tempList->student;	// return the student if found
		}

		tempList = tempList->next;		// parse the list
	}

	return NULL;						// return NULL if student not found in list
}

// Q3b: Define Friend Function changeRollNo()  (5 points)
// Define the function changeRollNo()that is declared in student.h
// This function sets the new roll number of the student. The student and new roll number is to be passed as function arguments.
// Use 'd' display option after using 'c' option to verify whether the new roll number is set.
// You will need to implement addStudent() and displayList() before you test this function.
void changeRollNo(Student* a, int b) {
	a -> rollNo = b; // chnage a rollNo to b
}


// Q4: addStudent  (10 points)
// This function is used to add a new student to the global linked list 'list'. You may add the new student to head or tail of the list. (Sample solution adds to tail)
// New student can be either undergrad or grad. You will need to use the function argument �type� to determine which constructor to use to create new student node.
// For example, if the user enters undergrad student, then you need to use Undergrad class and constructor to create new student node and add it to the list.
// NOTE: In executeAction(), searchStudent() is called before this function. Therefore no need to check here if the student exists in the list.
//       See how this fucntion is called in case 'a' of executeAction()

void addStudent(string name_input, int rollNo_input, studentType type)
{
	Container* tempList = list;				// work on a copy of 'list'
	Student* newStudent;
	if (type == 0) {		// determine whether undergraduate, graduate
		newStudent = new Undergrad(name_input, rollNo_input, type);
	}
	else {
		newStudent = new Grad(name_input, rollNo_input, type);
	}
	Container* Node = new Container;		// store new node
	Node->student = newStudent;
	Node->next = nullptr;
	if (tempList == nullptr) {				// store start at head
		list = Node;
	}
	else {
		Node->next = list;
		list = Node;
	}
}

// Q5: displayList	(10 points)
// This function displays the list of student and their details (roll number, student type)
// Parse the list and use the class member function to display the student info.
// See expected output in the question file.
void displayList()
{
	Container *tempList = list;			// work on a copy of 'list'
	while (tempList != NULL) {
		cout << endl;
		cout << endl;
		if (tempList->student->getstudentType() == 0) {
			cout << "Undergrad student: ";
		}
		else {
			cout << "Grad student: ";
		}
		cout << tempList->student->getName() << endl;	// display tempList name
		cout << "Roll number: ";
		cout << tempList->student->getRollNo() << endl;	// display tempList RollNo
		tempList = tempList->next;		// go next Node
	}
}

// Q6: removeStudent (10 points)
// This function removes the student whose name is passed as parameter.
// Parse the list to locate the student and delete that node without memory leak. 
// Removing the node will cause the list to break into 2 pieces.
// You will need to stitch those peices. See the list in this way: ...node1->studentToRemove->node2->...
// Remove the 'studentToRemove' node and stitch node1 to node2 so that list becomes: ...node1->node2->...
// Hint: You will need to separately consider the case when the 'studentToRemove node' is at the head of the list
void removeStudent(string name_input)
{
	Container* studentToRemove;
	Container* tempList = list;
	if (tempList->student->getName() == name_input) { // if remove node is head
		studentToRemove = tempList;
		list = tempList->next;		// move head pointer to head next node
		delete studentToRemove->student;	// delete memory
		delete studentToRemove;
	}
	else {
		while (tempList->next != NULL) {
			if (tempList->next->student->getName() == name_input) {	//if node is not head
				studentToRemove = tempList->next;	
				tempList->next = studentToRemove->next;	// previous node of remove node point next next node
				delete studentToRemove->student;
				delete studentToRemove;
				break;
			}
			else {
				tempList = tempList->next;
			}
		}
	}
}

// Q7: deleteList (10 points)
// This function deletes all the nodes of 'list'.
// Parse the list and delete the nodes one after another, without memory leak.
void deleteList()
{
	Container* tempList = list;
	while (tempList != NULL) {
		Container* Node = tempList->next;	// store tempList first before delete
		delete tempList->student;
		delete tempList;
		tempList = Node;	// go to next node
	}
	list = nullptr;		// reset head pointer
}

// Q8: sort() (10 points)
// This function sorts the list by student name alphabetically.
// You can create a new list of sorted students. In this case, you must delete the old list(garbage collection).
// You may look at books and websites for a suitable implementation of sorting and modify it as per the need of this program. 
// You must cite the book/website that you used.
// You may add function parameters and edit the declaration & function call of this function as per your implementation.

// Sources : CSE 100 howework7 bubbleSort

void sort(Container **head)
{

	Container** current = head;

	bool swapped;
	do {
		swapped = false;
		Container** current = head;

		while ((*current)->next != nullptr) {	// bubble sort logic
			Container* node1 = *current;
			Container* node2 = node1->next;

			if (node1->student->getName() > node2->student->getName()) {	// if previous node is bigger than current node than they change
				node1->next = node2->next;	// change two node
				node2->next = node1;
				*current = node2;
				swapped = true;
			}

			current = &((*current)->next);
		}
	} while (swapped);
}


// Q6: save  (10 points)
// Save the linked list of students to a file list.txt using ofstream.
// You will need to save the number of students in linked list. That will help in load() when reading the file.
// One format to store is:
// <no. of students>
// <Student1 name>
// <Student1 roll no.>
// <Student1 type>
// <Student2 name>
// <Student2 roll no.>
// <Student2 type>
// ...

// You may store the list in another format if you wish. You need to read the file in same way in load().
// This function is called when exiting the program (end of main() ).
// Hint: You may want to cast the enum �studentType� to an int before writing it to the file.

void save(string fileName)
{
	ofstream outFile(fileName);
	int count = 0;
	Container* temp = list;	
	while (temp != nullptr) {
		count++;
		temp = temp->next;
	}

	outFile << count << endl; // store studnent count
	temp = list;
	while (temp != nullptr) {	// store studnet information 
		outFile << temp->student->getName() << endl;
		outFile << temp->student->getRollNo() << endl;
		outFile << temp->student->getstudentType() << endl;
		temp = temp->next;
	}
	outFile.close();
}

// Q7: load (7 points)
// Load the linked list of students from the file using ifstream.
// You will need to create the linked list in the same order that is was saved to the file in save().
// First, read the number of students saved in the file.
// Then, for every student you will need to create a new node depending on student type. You may add the student to head or tail of the list. 
// Hint: If you casted the enum �studentType� to an int, you will need to cast it back to �studentType� when making the student node.
// This function is called at the beginning of main().

void load(string fileName)
{
	ifstream inFile(fileName);
	deleteList();
	int count;
	inFile >> count;
	inFile.ignore(); 
	for (int i = 0; i < count; i++) {
		string name;
		int rollNo, typeInt;

		getline(inFile, name);		// get studnent information from file
		inFile >> rollNo;             
		inFile >> typeInt;            
		inFile.ignore();              

		studentType type = static_cast<studentType>(typeInt);	// get studentType, using cast
		addStudent(name, rollNo, type);	// add student in the list
	}

	inFile.close();
}
